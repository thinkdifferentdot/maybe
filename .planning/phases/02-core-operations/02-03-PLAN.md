---
phase: 02-core-operations
plan: 03
type: execute
---

<objective>
Implement AutoMerchantDetector class with Anthropic Messages API and comprehensive error handling.

Purpose: Enable merchant detection through Anthropic Claude with proper error handling per CONTEXT requirements (fail loudly, no silent fallback).

Output: Provider::Anthropic::AutoMerchantDetector class that uses Anthropic's Messages API with error handling and JSON response parsing.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-operations/02-RESEARCH.md
@.planning/phases/02-core-operations/02-CONTEXT.md
@app/models/provider/openai.rb
@app/models/provider/openai/auto_merchant_detector.rb
@app/models/provider/llm_concept.rb
@app/models/provider/anthropic.rb
@app/models/provider/anthropic/auto_categorizer.rb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AutoMerchantDetector class structure</name>
  <files>app/models/provider/anthropic/auto_merchant_detector.rb</files>
  <action>Create Provider::Anthropic::AutoMerchantDetector class with:
1. Constructor accepting: client, model, transactions, user_merchants, langfuse_trace (optional), family (optional)
2. attr_reader for all constructor parameters
3. auto_detect_merchants method that calls the Anthropic API
4. Private methods: developer_message, json_schema, build_response, extract_merchants

Follow the structure from app/models/provider/openai/auto_merchant_detector.rb (lines 1-130, 175-270). This parallels AutoCategorizer but for merchant detection (business_name, business_url).</action>
  <verify>ruby -c app/models/provider/anthropic/auto_merchant_detector.rb passes</verify>
  <done>AutoMerchantDetector class created with constructor and auto_detect_merchants method</done>
</task>

<task type="auto">
  <name>Task 2: Implement Messages API call for merchant detection</name>
  <files>app/models/provider/anthropic/auto_merchant_detector.rb</files>
  <action>Implement the API call in auto_detect_merchants method:
1. Call @client.messages.create with:
   - model: @model or default
   - max_tokens: 1024
   - messages: [{role: "user", content: developer_message}]
   - system: instructions (from detailed_instructions method)
   - betas: ["structured-outputs-2025-11-13"] for structured outputs
2. Extract text content from response.content.find { |block| block.type == "text" }&.text
3. Parse JSON and extract "merchants" key
4. Use build_response to create AutoDetectedMerchant objects

The schema requires transaction_id, business_name, business_url fields. business_name and business_url can be null (string "null" for unknown).</action>
  <verify>grep -E "messages.create|betas.*structured" app/models/provider/anthropic/auto_merchant_detector.rb shows API call pattern</verify>
  <done>Messages API call with beta header for merchant detection</done>
</task>

<task type="auto">
  <name>Task 3: Implement prompt and schema for merchant detection</name>
  <files>app/models/provider/anthropic/auto_merchant_detector.rb</files>
  <action>Add private methods:
1. instructions - Return detailed instructions (reuse from OpenAI::AutoMerchantDetector detailed_instructions, lines 89-128)
2. developer_message - Format transactions and user_merchants as JSON
3. json_schema - Define JSON schema for merchants response with:
   - merchants array
   - Each item: transaction_id (enum), business_name (string or null), business_url (string or null)
   - required: transaction_id, business_name, business_url
   - additionalProperties: false

Merchant detection differs from categorization: it returns both name and URL, and uses "null" for unknown businesses (no guessing).</action>
  <verify>grep -E "def instructions|def developer_message|def json_schema" app/models/provider/anthropic/auto_merchant_detector.rb shows all three methods</verify>
  <done>Prompt and schema methods for merchant detection implemented</done>
</task>

<task type="auto">
  <name>Task 4: Add error handling with Anthropic-specific error types</name>
  <files>app/models/provider/anthropic/auto_merchant_detector.rb</files>
  <action>Wrap the API call in error handling that catches:
1. Anthropic::Errors::APIConnectionError - Re-raise as Provider::Anthropic::Error with "Failed to connect to Anthropic API"
2. Anthropic::Errors::RateLimitError - Re-raise as Provider::Anthropic::Error with "Rate limit exceeded"
3. Anthropic::Errors::APIStatusError - Re-raise as Provider::Anthropic::Error with status code
4. JSON::ParserError - Re-raise as Provider::Anthropic::Error with "Invalid JSON response"
5. Standard errors - Catch and re-raise as Provider::Anthropic::Error

Per CONTEXT.md: "fail loudly - no silent fallback to OpenAI." All errors should raise Provider::Anthropic::Error, not return nil or fall back.</action>
  <verify>grep -E "rescue.*Anthropic|rescue.*JSON" app/models/provider/anthropic/auto_merchant_detector.rb shows error handling</verify>
  <done>Anthropic-specific error types caught and re-raised as Provider::Anthropic::Error</done>
</task>

<task type="auto">
  <name>Task 5: Connect AutoMerchantDetector to Provider::Anthropic</name>
  <files>app/models/provider/anthropic.rb</files>
  <action>Add auto_detect_merchants method to Provider::Anthropic that:
1. Validates transactions.size <= 25 (raise Error if too many)
2. Creates Langfuse trace with name: "anthropic.auto_detect_merchants"
3. Instantiates AutoMerchantDetector with client, model, transactions, user_merchants, langfuse_trace, family
4. Calls auto_detect_merchants and updates trace with output
5. Returns result (array of AutoDetectedMerchant objects)

Follow the pattern from Provider::Openai#auto_detect_merchants (lines 87-113). Note: merchant detection doesn't require user_categories to be present (unlike categorization).</action>
  <verify>grep -E "def auto_detect_merchants|AutoMerchantDetector.new" app/models/provider/anthropic.rb shows delegation pattern</verify>
  <done>Provider::Anthropic#auto_detect_merchants delegates to AutoMerchantDetector with trace support</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `ruby -c app/models/provider/anthropic/auto_merchant_detector.rb` passes
- [ ] `ruby -c app/models/provider/anthropic.rb` passes
- [ ] Provider::Anthropic responds to auto_detect_merchants
- [ ] JSON schema matches expected format (transaction_id, business_name, business_url)
- [ ] Error handling catches Anthropic::Errors::* types
</verification>

<success_criteria>

- AutoMerchantDetector class implements merchant detection via Anthropic Messages API
- Structured outputs beta header used for JSON schema compliance
- Anthropic-specific error types handled properly
- Provider::Anthropic#auto_detect_merchants method works end-to-end
- Errors fail loudly (no silent fallback per CONTEXT.md requirement)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-core-operations/02-03-SUMMARY.md`:

# Phase 2 Plan 3: AutoMerchantDetector Summary

**Implemented Anthropic-based merchant detection with comprehensive error handling**

## Accomplishments

- Created Provider::Anthropic::AutoMerchantDetector class
- Implemented Messages API call with structured outputs for merchant detection
- Added prompt and JSON schema methods for merchants (business_name, business_url)
- Connected AutoMerchantDetector to Provider::Anthropic
- Added Anthropic-specific error handling (APIConnectionError, RateLimitError, etc.)
- Errors fail loudly per CONTEXT requirements (no silent fallback)

## Files Created/Modified

- `app/models/provider/anthropic/auto_merchant_detector.rb` - New merchant detection logic
- `app/models/provider/anthropic.rb` - Added auto_detect_merchants method

## Decisions Made

- Used structured outputs beta (2025-11-13) for schema compliance
- Reused OpenAI's merchant detection prompts (well-tested)
- All errors raise Provider::Anthropic::Error (fail loudly per CONTEXT)
- business_name and business_url can be null (string "null" for unknown)

## Issues Encountered

None

## Next Step

Phase 2: Core Operations complete - ready for Phase 3: Chat Support
</output>
